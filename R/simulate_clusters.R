#' Simulate Hawkes process cluster
#'
#' Simulate a cluster generated by the Hawkes process model up to a specified
#' horizon given the cluster over a specified observation window. In this case,
#' the offspring intensity is defined as \deqn{R \psi \exp (- \psi ( t - t_i))}
#' for \eqn{t > t_i} where \eqn{R} is the reproduction number and \eqn{\psi} is
#' the exponential decay rate for the generation interval density.
#'
#' @param observed_cluster_df A data frame containing the branching structure
#'   and timestamps for events in the observation window. The observed events
#'   seeding the cluster..
#' @param reproduction_number A positive real valued scalar. The expected number
#'   of offspring from each event.
#' @param gi_exp_decay_rate A positive real valued scalar. The exponential rate
#'   of decay in the density function of the generation interval distribution,
#' @param observation_horizon A real valued scalar. The time up to which events
#'   in the cluster are observed.
#' @param simulation_horizon A real valued scalar. The time up to which events
#'   in the cluster are simulated.
#' @param cluster_id A scalar.An arbitrary cluster label.
#' @inheritParams refactor_branching_structure
#'
#' @return A data frame with 4 variables: labels \eqn{id}; parent labels
#'   \eqn{parent_id}; timestamps \eqn{t}; generation label \eqn{gen}.
#' @export
simulate_hawkes_cluster <- function(
  observed_cluster_df,
  reproduction_number,
  gi_exp_decay_rate,
  observation_horizon, simulation_horizon,
  cluster_id = 0,
  perform_checks = TRUE
){
  N <- nrow(observed_cluster_df)
  if (perform_checks) {
    checkmate::assert_data_frame(
      observed_cluster_df
    )
    checkmate::assert_subset(
      c("id", "t", "parent_id"),
      colnames(observed_cluster_df)
    )
    checkmate::assert_numeric(observed_cluster_df$t, finite = TRUE)
    checkmate::assert_true(!(observed_cluster_df$parent_id[1] %in% observed_cluster_df$id))
    checkmate::assert_number(reproduction_number, lower = 0, finite = TRUE)
    if (reproduction_number >= 1)
      warning("Careful now. reproduction_number >= 1. The cluster process is no longer stationary")
    checkmate::assert_number(gi_exp_decay_rate, lower = 0, finite = TRUE)
    checkmate::assert_number(observation_horizon, lower = max(observed_cluster_df$t), finite = TRUE)
    checkmate::assert_number(simulation_horizon, lower = max(observation_horizon), finite = TRUE)
  }
  cluster_df <- dplyr::select(observed_cluster_df, id, parent_id, t)
  # Note generation of each observation
  cluster_df$gen <- NA
  i <- 1
  while (i <= nrow(cluster_df)) {
    if (!(cluster_df$parent_id[i] %in% cluster_df$id)) {
      cluster_df$gen[i] <- 0
    } else {
      cluster_df$gen[i] <- cluster_df$gen[cluster_df$parent_id[i] == cluster_df$id] + 1
    }
    i <- i+1
  }
  # Note observed offspring
  cluster_df$z_obs <- sapply(cluster_df$id, function(x) sum(cluster_df$parent_id == x))
  # Recursively Generate offspring
  cluster_df$z_sim <- NA
  i <- 1
  while (i <= nrow(cluster_df)) {
    tmp_F <-
      stats::pexp(simulation_horizon - cluster_df$t[i], rate = gi_exp_decay_rate) -
      stats::pexp(observation_horizon - cluster_df$t[i], rate = gi_exp_decay_rate)
    tmp_z <-
      stats::rpois(n = 1, lambda = reproduction_number * tmp_F)
    cluster_df$z_sim[i] <- tmp_z
    if (tmp_z > 0) {
      cluster_df <- rbind(
        cluster_df,
        data.frame(
          t = cluster_df$t[i] +
            truncdist::rtrunc(
              n = tmp_z,
              spec = "exp",
              a = observation_horizon - cluster_df$t[i],
              b = simulation_horizon - cluster_df$t[i],
              rate = gi_exp_decay_rate
            ),
          id = paste(cluster_id, i, 1:tmp_z, sep = "."),
          parent_id = cluster_df$id[i],
          gen = cluster_df$gen[i] + 1,
          z_obs = NA,
          z_sim = NA
        )
      )
    }
    i <- i+1
  }

  ord <- order(cluster_df$t)
  cluster_df <- dplyr::arrange(cluster_df, t)

  cluster_df$parent_id <- refactor_branching_structure(
    id = cluster_df$id,
    parent_id = cluster_df$parent_id,
    is_immigrant = cluster_df$gen == 0,
    S = min(nrow(cluster_df), 1000),
    perform_checks = FALSE
  )
  cluster_df$id <- seq_along(cluster_df$id)
  dplyr::select(cluster_df, id, parent_id, t, gen)
}

#' Simulate Doubly-Stochastic Hawkes process cluster
#'
#' Simulate a cluster generated by the doubly stochastic Hawkes process model up
#' to a specified horizon given the cluster over a specified observation window.
#' In this case, the offspring intensity is defined as \deqn{\nu_i \psi \exp (-
#' \psi ( t - t_i))} for \eqn{t > t_i} where \eqn{\nu_i} is the individual
#' reproduction number such that \eqn{E (\nu_i) = R} and \eqn{Var(\nu_i) = R +
#' R^2 / k}, and \eqn{\psi} is the exponential decay rate for the generation
#' interval density.
#'
#' @inheritParams simulate_hawkes_cluster
#' @param dispersion_parameter A positive real valued scalar. The dispersion
#'   parameter for offspring from each event, denoted \eqn{k}.
#' @inheritParams
#'
#' @return A data frame with 4 variables: timestamps \eqn{t}, labels \eqn{id};
#'   parent labels \eqn{parent_id}; cluster label \eqn{cluster_id}.
#' @export
simulate_ds_hawkes_cluster <- function(
  observed_cluster_df,
  reproduction_number, dispersion_parameter,
  gi_exp_decay_rate,
  observation_horizon, simulation_horizon,
  cluster_id = 0,
  perform_checks = TRUE
){
  N <- nrow(observed_cluster_df)
  if (perform_checks) {
    checkmate::assert_data_frame(
      observed_cluster_df
    )
    checkmate::assert_subset(
      c("id", "t", "parent_id"),
      colnames(observed_cluster_df)
    )
    checkmate::assert_numeric(observed_cluster_df$t, finite = TRUE)
    checkmate::assert_true(!(observed_cluster_df$parent_id[1] %in% observed_cluster_df$id))
    checkmate::assert_number(reproduction_number, lower = 0, finite = TRUE)
    if (reproduction_number >= 1)
      warning("Careful now. reproduction_number >= 1. The cluster process is no longer stationary")
    checkmate::assert_number(dispersion_parameter, lower = 0, finite = TRUE)
    checkmate::assert_number(gi_exp_decay_rate, lower = 0, finite = TRUE)
    checkmate::assert_number(observation_horizon, lower = max(observed_cluster_df$t), finite = TRUE)
    checkmate::assert_number(simulation_horizon, lower = max(observation_horizon), finite = TRUE)
  }
  cluster_df <- dplyr::select(observed_cluster_df, id, parent_id, t)
  # Note generation of each observation
  cluster_df$gen <- NA
  i <- 1
  while (i <= nrow(cluster_df)) {
    if (!(cluster_df$parent_id[i] %in% cluster_df$id)) {
      cluster_df$gen[i] <- 0
    } else {
      cluster_df$gen[i] <- cluster_df$gen[cluster_df$parent_id[i] == cluster_df$id] + 1
    }
    i <- i+1
  }
  # Note observed offspring
  cluster_df$z_obs <- sapply(cluster_df$id, function(x) sum(cluster_df$parent_id == x))
  # Sample individual reproduction numbersÒ
  post <- gamma_posterior_individual_reproduction_number(
    t = cluster_df$t, observed_offspring = cluster_df$z_obs,
    observation_horizon = observation_horizon,
    reproduction_number = reproduction_number,
    dispersion_parameter = dispersion_parameter,
    gi_exp_decay_rate = gi_exp_decay_rate,
    sinusoid_coefficients = NULL, sinusoid_frequencies = NULL,
    perform_checks = FALSE
  )
  nu <- stats::rgamma(N, post$shape, post$rate)
  cluster_df$nu <- nu
  # Recursively Generate offspring
  cluster_df$z_sim <- NA
  i <- 1
  while (i <= nrow(cluster_df)) {
    tmp_F <-
      stats::pexp(simulation_horizon - cluster_df$t[i], rate = gi_exp_decay_rate) -
      stats::pexp(observation_horizon - cluster_df$t[i], rate = gi_exp_decay_rate)
    tmp_z <-
      stats::rpois(n = 1, lambda = cluster_df$nu[i] * tmp_F)
    cluster_df$z_sim[i] <- tmp_z
    if (tmp_z > 0) {
      cluster_df <- rbind(
        cluster_df,
        data.frame(
          t = cluster_df$t[i] +
            truncdist::rtrunc(
              n = tmp_z,
              spec = "exp",
              a = observation_horizon - cluster_df$t[i],
              b = simulation_horizon - cluster_df$t[i],
              rate = gi_exp_decay_rate
            ),
          id = paste(cluster_id, i, 1:tmp_z, sep = "."),
          parent_id = cluster_df$id[i],
          gen = cluster_df$gen[i] + 1,
          z_obs = NA,
          nu = stats::rgamma(tmp_z, shape = dispersion_parameter, rate = dispersion_parameter / reproduction_number),
          z_sim = NA
        )
      )
    }
    i <- i+1
  }

  ord <- order(cluster_df$t)
  cluster_df <- dplyr::arrange(cluster_df, t)

  cluster_df$parent_id <- refactor_branching_structure(
    id = cluster_df$id,
    parent_id = cluster_df$parent_id,
    is_immigrant = cluster_df$gen == 0,
    S = min(nrow(cluster_df), 1000),
    perform_checks = FALSE
  )
  cluster_df$id <- seq_along(cluster_df$id)
  dplyr::select(cluster_df, id, parent_id, t, gen)
}

#' Simulate Time-Dependant Hawkes process cluster
#'
#' Simulate a cluster generated by the time-dependant Hawkes process model up to
#' a specified horizon given the cluster over a specified observation window. In
#' this case, the offspring intensity is defined as \deqn{R \psi \rho (t) \exp
#' (- \psi ( t - t_i))} for \eqn{t > t_i} where \eqn{R} is the reproduction
#' number, \eqn{\rho (t)} is the relative activity function, and \eqn{\psi} is
#' the exponential decay rate for the generation interval density.
#'
#' @inheritParams simulate_hawkes_cluster
#' @inheritParams sinusoidal_function
#' @param dominating_scalar A positive real valued scalar greater than \eqn{\rho
#'   (t)} for all \eqn{t}. Allows Lewis thinning for simulating the offspring
#'   process.
#'
#' @return A data frame with 4 variables: timestamps \eqn{t}, labels \eqn{id};
#'   parent labels \eqn{parent_id}; cluster label \eqn{cluster_id}.
#' @export
simulate_tide_hawkes_cluster <- function(
  observed_cluster_df,
  reproduction_number,
  gi_exp_decay_rate,
  sinusoid_coefficients, sinusoid_frequencies,
  observation_horizon, simulation_horizon,
  dominating_scalar = 2,
  cluster_id = 0,
  perform_checks = TRUE
){
  N <- nrow(observed_cluster_df)
  K <- length(sinusoid_frequencies)
  if (perform_checks) {
    checkmate::assert_data_frame(
      observed_cluster_df
    )
    checkmate::assert_subset(
      c("id", "t", "parent_id"),
      colnames(observed_cluster_df)
    )
    checkmate::assert_numeric(observed_cluster_df$t, finite = TRUE)
    checkmate::assert_true(!(observed_cluster_df$parent_id[1] %in% observed_cluster_df$id))
    checkmate::assert_number(reproduction_number, lower = 0, finite = TRUE)
    if (reproduction_number >= 1)
      warning("Careful now. reproduction_number >= 1. The cluster process is no longer stationary")
    checkmate::assert_number(gi_exp_decay_rate, lower = 0, finite = TRUE)
    checkmate::assert_number(dominating_scalar, lower = 1, finite = TRUE)
    checkmate::assert_number(observation_horizon, lower = max(observed_cluster_df$t), finite = TRUE)
    checkmate::assert_number(simulation_horizon, lower = max(observation_horizon), finite = TRUE)
    checkmate::assert_numeric(sinusoid_coefficients, any.missing = FALSE, len = 2*K)
    A <- sapply(1:K, function(k){sqrt(sum(sinusoid_coefficients[2 * (k-1) + 1:2]^2))})
    if (sum(A > 1)) {
      warning("sinusoid_coefficients too large, may imply negative intensity values")
    }
    checkmate::assert_numeric(sinusoid_frequencies, any.missing = FALSE, lower = 0)
  }
  cluster_df <- dplyr::select(observed_cluster_df, id, parent_id, t)
  # Note generation of each observation
  cluster_df$gen <- NA
  i <- 1
  while (i <= nrow(cluster_df)) {
    if (!(cluster_df$parent_id[i] %in% cluster_df$id)) {
      cluster_df$gen[i] <- 0
    } else {
      cluster_df$gen[i] <- cluster_df$gen[cluster_df$parent_id[i] == cluster_df$id] + 1
    }
    i <- i+1
  }
  # Note observed offspring
  cluster_df$z_obs <- sapply(cluster_df$id, function(x) sum(cluster_df$parent_id == x))
  # Recursively Generate offspring
  cluster_df$z_sim <- NA
  i <- 1
  while (i <= nrow(cluster_df)) {
    tmp_F <-
      stats::pexp(simulation_horizon - cluster_df$t[i], rate = gi_exp_decay_rate) -
      stats::pexp(observation_horizon - cluster_df$t[i], rate = gi_exp_decay_rate)
    tmp_z <-
      stats::rpois(n = 1, lambda = dominating_scalar * reproduction_number * tmp_F)
    if (tmp_z > 0) {
      tmp_t <- cluster_df$t[i] +
        truncdist::rtrunc(
          n = tmp_z,
          spec = "exp",
          a = observation_horizon - cluster_df$t[i],
          b = simulation_horizon - cluster_df$t[i],
          rate = gi_exp_decay_rate
        )
      tmp_p <- (1 + sinusoidal_function(
        t = tmp_t,
        sinusoid_coefficients = sinusoid_coefficients,
        sinusoid_frequencies = sinusoid_frequencies,
        perform_checks = FALSE
        )
      ) / dominating_scalar
      thin_ind <- as.logical(stats::rbinom(tmp_z, size = 1, prob = tmp_p))
      if (sum(thin_ind) > 0) {
        cluster_df <- rbind(
          cluster_df,
          data.frame(
            t = tmp_t[thin_ind],
            id = paste(cluster_id, i, 1:sum(thin_ind), sep = "."),
            parent_id = cluster_df$id[i],
            gen = cluster_df$gen[i] + 1,
            z_obs = NA,
            z_sim = NA
          )
        )
        cluster_df$z_sim <- sum(thin_ind)
      } else {
        cluster_df$z_sim <- 0
      }
    } else {
      cluster_df$z_sim <- 0
    }
    i <- i+1
  }

  ord <- order(cluster_df$t)
  cluster_df <- dplyr::arrange(cluster_df, t)

  cluster_df$parent_id <- refactor_branching_structure(
    id = cluster_df$id,
    parent_id = cluster_df$parent_id,
    is_immigrant = cluster_df$gen == 0,
    S = min(nrow(cluster_df), 1000),
    perform_checks = FALSE
  )
  cluster_df$id <- seq_along(cluster_df$id)
  dplyr::select(cluster_df, id, parent_id, t, gen)
}

#' Simulate a Time-Dependant Doubly-Stochastic Hawkes process cluster
#'
#' Simulate a cluster generated by the Time-Dependant Doubly-Stochastic Hawkes
#' process model up to a specified horizon, given an initial observation
#' interval. In this case, we have an offspring intensity \deqn{\nu_i \rho (t)
#' \psi \exp (- \psi ( t - t_i))} for \eqn{t > t_i} where \eqn{\nu_i} is the
#' latent individual reproduction number and \eqn{\psi} is the exponential decay
#' rate for the generation interval density, and \deqn{\rho (t) = \sum_{k = 1}^K
#' \beta_{2k - 1} sin(\omega_k t ) + \beta_{2k} cos(\omega_k t )} is the
#' relative activity function modulating the offspring intensity. The individual
#' reproduction number has a Gamma distributed prior with shape \eqn{k} and rate
#' \eqn{k / R}.
#'
#' @inheritParams simulate_tide_hawkes_cluster
#' @inheritParams simulate_ds_hawkes_cluster
#'
#' @return A data frame with 4 variables: timestamps \eqn{t}, labels \eqn{id};
#'   parent labels \eqn{parent_id}; cluster label \eqn{cluster_id}.
#' @export
simulate_tide_ds_hawkes_cluster <- function(
  observed_cluster_df,
  reproduction_number, dispersion_parameter,
  gi_exp_decay_rate,
  sinusoid_coefficients, sinusoid_frequencies,
  observation_horizon, simulation_horizon,
  dominating_scalar = 2,
  cluster_id = 0,
  perform_checks = TRUE
){
  N <- nrow(observed_cluster_df)
  K <- length(sinusoid_frequencies)
  if (perform_checks) {
    checkmate::assert_data_frame(
      observed_cluster_df
    )
    checkmate::assert_subset(
      c("id", "t", "parent_id"),
      colnames(observed_cluster_df)
    )
    checkmate::assert_numeric(observed_cluster_df$t, finite = TRUE)
    checkmate::assert_true(!(observed_cluster_df$parent_id[1] %in% observed_cluster_df$id))
    checkmate::assert_number(reproduction_number, lower = 0, finite = TRUE)
    if (reproduction_number >= 1)
      warning("Careful now. reproduction_number >= 1. The cluster process is no longer stationary")
    checkmate::assert_number(dispersion_parameter, lower = 0, finite = TRUE)
    checkmate::assert_number(gi_exp_decay_rate, lower = 0, finite = TRUE)
    checkmate::assert_number(dominating_scalar, lower = 1, finite = TRUE)
    checkmate::assert_number(observation_horizon, lower = max(observed_cluster_df$t), finite = TRUE)
    checkmate::assert_number(simulation_horizon, lower = max(observation_horizon), finite = TRUE)
    checkmate::assert_numeric(sinusoid_coefficients, any.missing = FALSE, len = 2*K)
    A <- sapply(1:K, function(k){sqrt(sum(sinusoid_coefficients[2 * (k-1) + 1:2]^2))})
    if (sum(A > 1)) {
      warning("sinusoid_coefficients too large, may imply negative intensity values")
    }
    checkmate::assert_numeric(sinusoid_frequencies, any.missing = FALSE, lower = 0)
  }
  cluster_df <- dplyr::select(observed_cluster_df, id, parent_id, t)
  # Note generation of each observation
  cluster_df$gen <- NA
  i <- 1
  while (i <= nrow(cluster_df)) {
    if (!(cluster_df$parent_id[i] %in% cluster_df$id)) {
      cluster_df$gen[i] <- 0
    } else {
      cluster_df$gen[i] <- cluster_df$gen[cluster_df$parent_id[i] == cluster_df$id] + 1
    }
    i <- i+1
  }
  # Note observed offspring
  cluster_df$z_obs <- sapply(cluster_df$id, function(x) sum(cluster_df$parent_id == x))
  # Sample individual reproduction numbersÒ
  post <- gamma_posterior_individual_reproduction_number(
    t = cluster_df$t, observed_offspring = cluster_df$z_obs,
    observation_horizon = observation_horizon,
    reproduction_number = reproduction_number,
    dispersion_parameter = dispersion_parameter,
    gi_exp_decay_rate = gi_exp_decay_rate,
    sinusoid_coefficients = sinusoid_coefficients, sinusoid_frequencies = sinusoid_frequencies,
    perform_checks = FALSE
  )
  nu <- stats::rgamma(N, post$shape, post$rate)
  cluster_df$nu <- nu
  # Recursively Generate offspring
  cluster_df$z_sim <- NA
  i <- 1
  while (i <= nrow(cluster_df)) {
    tmp_F <-
      stats::pexp(simulation_horizon - cluster_df$t[i], rate = gi_exp_decay_rate) -
      stats::pexp(observation_horizon - cluster_df$t[i], rate = gi_exp_decay_rate)
    tmp_z <-
      stats::rpois(n = 1, lambda = dominating_scalar * cluster_df$nu[i] * tmp_F)
    if (tmp_z > 0) {
      tmp_t <- cluster_df$t[i] +
        truncdist::rtrunc(
          n = tmp_z,
          spec = "exp",
          a = observation_horizon - cluster_df$t[i],
          b = simulation_horizon - cluster_df$t[i],
          rate = gi_exp_decay_rate
        )
      tmp_p <- (1 + sinusoidal_function(
        t = tmp_t,
        sinusoid_coefficients = sinusoid_coefficients,
        sinusoid_frequencies = sinusoid_frequencies
        )
      ) / dominating_scalar
      tmp_nu <- stats::rgamma(tmp_z, shape = dispersion_parameter, rate = dispersion_parameter / reproduction_number)
      thin_ind <- as.logical(stats::rbinom(tmp_z, size = 1, prob = tmp_p))
      if (sum(thin_ind) > 0) {
        cluster_df <- rbind(
          cluster_df,
          data.frame(
            t = tmp_t[thin_ind],
            id = paste(cluster_id, i, 1:sum(thin_ind), sep = "."),
            parent_id = cluster_df$id[i],
            gen = cluster_df$gen[i] + 1,
            z_obs = NA,
            nu = tmp_nu[thin_ind],
            z_sim = NA
          )
        )
        cluster_df$z_sim <- sum(thin_ind)
      } else {
        cluster_df$z_sim <- 0
      }
    } else {
      cluster_df$z_sim <- 0
    }
    i <- i+1
  }

  ord <- order(cluster_df$t)
  cluster_df <- dplyr::arrange(cluster_df, t)

  cluster_df$parent_id <- refactor_branching_structure(
    id = cluster_df$id,
    parent_id = cluster_df$parent_id,
    is_immigrant = cluster_df$gen == 0,
    S = min(nrow(cluster_df), 1000),
    perform_checks = FALSE
  )
  cluster_df$id <- seq_along(cluster_df$id)
  dplyr::select(cluster_df, id, parent_id, t, gen)
}
